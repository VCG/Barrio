<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>

<style>
    div.tooltip {
        position: absolute;
        text-align: match-parent;
        width: auto;
        height: auto;
        padding: 3px;
        font: 12px sans-serif;
        background: lightgray;
        border: 0px;
        border-radius: 4px;
        pointer-events: none;
    }

    .label {
        font-family: 'Nanum Gothic', sans-serif;
        text-anchor: middle;
    }

    .mito {
        border-radius: 100px;
        fill: palevioletred;
    }
</style>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz" style="width: auto; height: 400px"></div>

<script src="qrc:///qtwebchannel/qwebchannel.js" type="text/javascript"></script>
<script crossorigin="anonymous"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>

<script>
    new QWebChannel(qt.webChannelTransport, function (channel) {

        let jsobject = channel.objects.mitoboxplot_data;
        let json_string = jsobject.json_string;
        let data = JSON.parse(json_string);

        // set the dimensions and margins of the graph
        let margin = {top: 10, right: 30, bottom: 30, left: 40},
            width = 460 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        // Append Div for tooltip to SVG
        let div = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        // append the svg object to the body of the page
        let svg = d3.select("#my_dataviz")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        let cell_names = [];
        for (let cell of data) {
            cell_names.push(cell.name)
        }

        // Show the X scale
        let x = d3.scaleBand()
            .range([0, width])
            .domain(cell_names)
            .paddingInner(1)
            .paddingOuter(.5);
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x))

        // Show the Y scale
        let y = d3.scaleLinear()
            .domain([0, 1])
            .range([height, 0]);
        svg.append("g").call(d3.axisLeft(y))

        let boxWidth = 15;
        for (let i = 0; i < data.length; i++) {
            let cell_length = data[i].length;
            let cell_name = data[i].name;
            svg.selectAll("boxes")
                .data(data[i].mitochondria)
                .enter()
                .append("rect")
                .attr("x", function (d) {
                    return (x(cell_name) - boxWidth / 2)
                })
                .attr("y", function (d) {
                    return (y(d.end / cell_length))
                })
                .attr("height", function (d) {
                    return (y(d.start / cell_length))
                })
                .attr("width", boxWidth)
                .attr("class", "mito")
                .on("mouseover", function (d) {
                    div.transition()
                        .duration(200)
                        .style("opacity", .9);

                    div.text(d.name)
                        .style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function () {
                    div.transition()
                        .duration(100)
                        .style("opacity", 0);
                });
        }

        for (let i = 0; i < data.length; i++) {
            let cell_length = data[i].length;
            svg.selectAll("medianLines")
                .data(data[i].spines)
                .enter()
                .append("line")
                .attr("x1", function (spine) {
                    return (x(data[i].name) - boxWidth / 2)
                })
                .attr("x2", function (spine) {
                    return (x(data[i].name) + boxWidth / 2)
                })
                .attr("y1", function (spine) {
                    if(hasMitoCoverage(data[i], spine.start)) {
                        return (y(spine.start / cell_length))
                    }
                })
                .attr("y2", function (spine) {
                    if(hasMitoCoverage(data[i], spine.start)) {
                        return (y(spine.start / cell_length))
                    }
                })
                .attr("stroke", "black")
                .style("width", 120)
        }

        function hasMitoCoverage(cell, start) {
            let mitos = cell.mitochondria;
            for(let i = 0; i < mitos.length; i++)
            {
                if(mitos[i].start <= start && start <= mitos[i].end)
                {
                    return true;
                }
            }
            return false


        }
    })

</script>