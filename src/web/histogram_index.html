<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>
<script type="text/javascript" src="qrc:///qtwebchannel/qwebchannel.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700&display=swap" rel="stylesheet">

<style>
    .label {
        font-family: 'Nanum Gothic', sans-serif;
        text-anchor: middle;
    }
</style>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>

<script>
    new QWebChannel(qt.webChannelTransport, function (channel) {

        let jsobject = channel.objects.histogram_data;
        let json_string = jsobject.json_string;
        let number_of_bins = jsobject.number_of_bins;
        let colormap = jsobject.colormap;

        let my_data = JSON.parse(json_string);
        let colors = JSON.parse(colormap);
        let number_of_samples = Object.keys(my_data).length;

        // set the dimensions and margins of the graph
        let margin = {top: 10, right: 30, bottom: 55, left: 60},
            width = 460 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        let svg = d3.select("#my_dataviz")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        // X axis: scale and draw:
        let x = d3.scaleLinear()
            .domain([0, 0.3])     // can use this instead of 1000 to have the max of data: d3.max(data, function(d) { return +d.price })
            .range([0, width]);

        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));

        // Y axis: initialization
        let y = d3.scaleLinear()
            .domain([0, 1])
            .range([height, 0]);

        let colorScale = d3.scaleQuantize()
            .domain([0, 1.0])
            .range(colors);

        let yAxis = svg.append("g");

        // taxt label for x-axis
        svg.append("text")
            .attr("transform",
                "translate(" + (width/2) + " ," +
                (height + margin.top + 25) + ")")
            .attr("class", "label")
            .text("Distance to Cell Boundary");

        // text label for the y axis
        svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1.0em")
            .attr("class", "label")
            .text("% of surface");

        // A function that builds the graph for a specific value of bin
        function update(nBin) {

            // set the parameters for the histogram
            let histogram = d3.histogram()
                .value(function (d) {
                    return d.dist;
                })   // I need to give the vector of value
                .domain(x.domain())  // then the domain of the graphic
                .thresholds(x.ticks(nBin, "s")); // then the numbers of bins

            // And apply this function to data to get the bins
            let bins = histogram(my_data);

            yAxis.transition()
                .duration(1000)
                .call(d3.axisLeft(y).tickFormat(d3.format(".0%")));

            // computing cummulative data
            for (let i = 0; i < bins.length; i++) {
                if (i > 0) {
                    bins[i].percentage = bins[i].length / number_of_samples + bins[i - 1].percentage;
                } else {
                    bins[i].percentage = bins[i].length / number_of_samples;
                }
            }

            // Join the rect with the bins data
            let u = svg.selectAll("rect")
                .data(bins);

            // Manage the existing bars and eventually the new ones:
            u.enter()
                .append("rect") // Add a new rect for each new elements
                .merge(u) // get the already existing elements as well
                .transition() // and apply changes to all of them
                .duration(1000)
                .attr("x", 1)
                .attr("transform", function (d) {
                    return "translate(" + x(d.x0) + "," + y(d.percentage) + ")";
                })
                .attr("width", function (d) {
                    return x(d.x1) - x(d.x0) - 1;
                })
                .attr("height", function (d) {
                    return height - y(d.percentage);
                })
                .style("fill", function (d) {
                    return colorScale(1 - d.x0 * 4.0);
                })

            // If less bar in the new histogram, I delete the ones not in use anymore
            u.exit().remove()
        }

        update(number_of_bins);
    });
</script>